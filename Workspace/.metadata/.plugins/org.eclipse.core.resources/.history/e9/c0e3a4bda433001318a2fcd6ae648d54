package general;

import java.util.LinkedList;
import java.util.List;

import junit.framework.Assert;

public class BinaryTree implements Cloneable{
	
	Node root;
	
	boolean allowDuplicateValues = false;
	
	public BinaryTree() {
		super();
	}
	
	public BinaryTree(Node root) {
		super();
		this.root = root;
	}
	
	public BinaryTree(boolean allowDuplicateValues) {
		super();
		this.allowDuplicateValues = allowDuplicateValues;
	}
	
	public BinaryTree(Node root, boolean allowDuplicateValues) {
		super();
		this.root = root;
		this.allowDuplicateValues = allowDuplicateValues;
	}

	public class Node {
		
		private Integer data;
		private Node leftChild;
		private Node rightChild;
		
		private Node parent;
		
		public Node getParent() {
			return parent;
		}

		public void setParent(Node parent) {
			this.parent = parent;
		}

		public Integer getData() {
			return data;
		}

		public void setData(Integer data) {
			this.data = data;
		}

		public Node getLeftChild() {
			return leftChild;
		}

		public void setLeftChild(Node leftChild) {
			this.leftChild = leftChild;
		}

		public Node getRightChild() {
			return rightChild;
		}

		public void setRightChild(Node rightChild) {
			this.rightChild = rightChild;
		}
		
		Node (Integer data) {
			
			this.data = data;
		}

		@Override
		public String toString() {
			return "Node [data=" + data + ", leftChild=" + leftChild
					+ ", rightChild=" + rightChild + "]";
		}



	}
	
	public boolean insertNode(Integer data) {
		
		Node node = new Node(data);
		
		if(null == root) {
			root = node; 
			return true;
		} else {
			
			if(!allowDuplicateValues && hasValue(data)){
				System.out.println("Value already exists");
				return false;
			}
			
			Node current = root;
			
			while(true) {
				int cValue = current.getData().compareTo(data);
			    if(cValue > 0) {
			    	if(null == current.getLeftChild()) {
			    		current.setLeftChild(node);
			    		node.setParent(current);
			    		return true;
			    	} 

			    	current = current.getLeftChild();
					
				} else {
					if(null == current.getRightChild()) {
			    		current.setRightChild(node);
			    		node.setParent(current);
			    		return true;
			    	} else {
			    		current = current.getRightChild();
			    	}
					
				}
			}
			
		}

	}
	
	public Node getParent(Integer data) {
		
		if(!hasValue(data))
			return null;
		
		//Node node = new Node(data);
		
		if (null == this.root) {
			return null;
		}
		
		if(data == root.getData())
			return null;
		
		Node currentNode = root;
		Node parent = null;
		
		while(true) {
			int compareValue = currentNode.getData().compareTo(data);
			if(compareValue == 0) {
				return parent;
			}
			if(compareValue > 0) {
				parent = currentNode;
				currentNode = currentNode.getLeftChild();
			}
			if(compareValue < 0) {
				parent = currentNode;
				currentNode = currentNode.getRightChild();
			}
			
		}
		
	}
	
	public boolean hasValue(Integer value) {
		
		if (null == root)
			return false;
		
		Node current = root;
		
		while(true) {
			if (null == current) 
				return false;
			
			if(current.getData() == value) {
				return true;
			} else {
				if(value < current.getData()) {
					current = current.getLeftChild();
					continue;
				} else {
					current = current.getRightChild();
					continue;
				}
			}
		}
		
	}
	
	public boolean deleteNode(Integer data) {
		
		if (hasValue(data)) {
			
			Node parent = getParent(data);
			Node current;
			
			if(parent.getLeftChild().getData() == data) { // it is left child
				current = parent.getLeftChild();
				if((null ==current.getLeftChild()) && (null == current.getRightChild())) {
					current = null;
					return true;
				}
				if((null !=current.getLeftChild()) && (null == current.getRightChild())) {
					current.getLeftChild().setParent(parent);
					parent.setLeftChild(current.getLeftChild());
					current = null;
					return true;
				}
				if((null !=current.getRightChild()) && (null == current.getLeftChild())) {
					current.getRightChild().setParent(parent);
					parent.setLeftChild(current.getRightChild());
					current = null;
					return true;
				}
				// if both sub trees are present
				
			} else { // it is a right child
				current = parent.getRightChild();
				if((null ==current.getLeftChild()) && (null == current.getRightChild())) {
					current = null;
					return true;
				}
				if((null !=current.getLeftChild()) && (null == current.getRightChild())) {
					current.getLeftChild().setParent(parent);
					parent.setRightChild(current.getLeftChild());
					current = null;
					return true;
				}
				if((null !=current.getRightChild()) && (null == current.getLeftChild())) {
					current.getRightChild().setParent(parent);
					parent.setRightChild(current.getRightChild());
					current = null;
					return true;
				}
				// if both sub trees are present
				Node nodeToSwap = getMaxValueLesserThanNode(current);
				if(null==nodeToSwap) {
					return false;
				}
				if(nodeToSwap == current) {
					current = null;
					return true;
				} else {
					current.setData(nodeToSwap.getData());
					nodeToSwap = null;
					return true;
				}
			}
			// 
			
		} else {
			System.out.println("Tree does not have the value");
			return false;
		}
		
		return false;
	}
	
	/**
	 * @param node the node for which the level is needed
	 * @return the level of the node (level of root is 0)
	 */
	public int getLevel(Integer data) {
		
		if(!hasValue(data)) {
			return -1;
		}
		
		if(null==data)
			return -1;
		
		if(null==root)
			return -1;
		
		if(root.getData()==data)
			return 0;
		
		int level = 0;
		Node current = root;
		
		while(null != current) {
			int compareValue = data.compareTo(current.getData());
			
			if(compareValue == 0) {
				return level;
			} else if (compareValue < 0) {
				current = current.getLeftChild();
				
			} else {
				current = current.getRightChild();
			}
			level++;
		}
		
		Assert.assertFalse(true); // should not come here. CHECK the logic

		return level; 
	}
	
	public int getSmallestValue() {
		
		if (null==root)
			return -1;
		
		if(null==root.getLeftChild())
			return root.getData();
		
		Node node = root;
		while(null!=node.getLeftChild()) {
			node = node.getLeftChild();
		}
			
		return node.getData();
	}
	
	public int getLargestValue() {
		
		if (null==root)
			return -1;
		
		if(null==root.getRightChild())
			return root.getData();
		
		Node node = root;
		while(null!=node.getRightChild()) {
			node = node.getRightChild();
		}
			
		return node.getData();
	}
	
	public boolean isLeaf(Node node) {
		if (null==node)
			return false;
		
		if((null == node.getLeftChild()) && (null == node.getRightChild()))
			return true;
		
		return false;
	}
	
	public List<Integer> levelOrderTraversal() {
		if (root == null)
			return null;
		
		if((root.getLeftChild() == null) && (root.getRightChild() == null)) {
			//System.out.println(root.getData());
			return null;
		}
		
		System.out.println(root.getData());
		Node current = root;
		List<Integer> list = new LinkedList<Integer>(); 
		List<Node> queue = new LinkedList<Node>(); 
		// breadth first
		queue.add(root);
		
		while (queue.size() !=0) {
		    current = queue.get(0);
		    list.add(current.getData());
			if(null != current.getLeftChild()) {
				queue.add(current.getLeftChild());
				//list.add(current.getLeftChild().getData());
			}
			if(null != current.getRightChild()) {
				queue.add(current.getRightChild());
				//list.add(current.getRightChild().getData());
			}
			queue.remove(0);
		}
		
		return list;
	}

	public List<Integer> inOrderTravesal (Node node) {

		List<Integer> list = new LinkedList<Integer>();
		if(null==root)
			return null;
		
		if((null==root.getLeftChild()) && (null==root.getRightChild())) {
			list.add(root.getData());
			return list;
		}
		
		Node current = node;
		
		//base case
		if(isLeaf(current)) {
			list.add(current.data);
			return list;
		} else if (null == current.getRightChild()) {
			list.addAll(inOrderTravesal(current.getLeftChild()));
			return list;
		} else if(null == current.getLeftChild()) {
			list.add(current.getData());
			list.addAll(inOrderTravesal(current.getRightChild()));
			return list;
		} else {
			list.addAll(inOrderTravesal(current.getLeftChild()));
			list.add(current.getData());
			list.addAll(inOrderTravesal(current.getRightChild()));
			return list;
		}

	}

	
	public List<Integer> preOrderTravesal (Node node) {

		List<Integer> list = new LinkedList<Integer>();
		if(null==root)
			return null;
		
		if((null==root.getLeftChild()) && (null==root.getRightChild())) {
			list.add(root.getData());
			return list;
		}
		
		Node current = node;
		
		System.out.println("--> " + current.getData());
		//base case
		if(isLeaf(current)) {
			System.out.println("is leaf ");
			list.add(current.data);

			System.out.println("list: " + list);
			return list;
		} else if (null == current.getRightChild()) {
			System.out.println("has only left child ");
			list.addAll(inOrderTravesal(current.getLeftChild()));

			System.out.println("list: " + list);
			return list;
		} else if(null == current.getLeftChild()) {
			System.out.println("has only right child ");
			list.add(current.getData());
			list.addAll(inOrderTravesal(current.getRightChild()));

			System.out.println("list: " + list);
			return list;
		} else {
			System.out.println("has both children ");
			list.addAll(inOrderTravesal(current.getLeftChild()));
			list.add(current.getData());
			list.addAll(inOrderTravesal(current.getRightChild()));

			System.out.println("list: " + list);
			return list;
		}
		
	}
	
	public List<Integer> postOrderTravesal () throws CloneNotSupportedException {
		
		BinaryTree clone = (BinaryTree) this.clone();

		if (clone.root == null)
			return null;
		
		Node current = clone.root;
		Node parent = null;
		List<Integer> list = new LinkedList<Integer>(); 
		List<Node> queue = new LinkedList<Node>(); 
		// breadth first
		queue.add(clone.root);
		current = queue.get(0);
		
		while (queue.size() !=0) {
			
			if(null == current)
				current = clone.root;
			
			while (null != current.getLeftChild()) {
				current = current.getLeftChild();
			}
			
			//queue.add(0, current);
			
			if(clone.isLeaf(current)) {
				list.add(current.getData());
				//queue.remove(current.getData());
				clone.deleteNode(current.getData());
			} else {
				current = current.getRightChild();
			}
			
		}
		
		
		
		
		
		
		while (queue.size() !=0) {
			
			if ((null == current.getLeftChild()) && (null == current.getRightChild())) { 
				list.add(current.getData());
				//System.out.println("one: " + current.getData());
				clone.deleteNode(current.getData());
				queue.remove(0);
			}
			if (null != current.getLeftChild()) {
				
				//System.out.println("current - >" + current.getData());
				
				while(null != current.getLeftChild()) {
					parent = current;
					current = current.getLeftChild();
				}
				
				queue.add(0, parent);
				list.add(current.getData());
				//System.out.println("two: " + queue);
				clone.deleteNode(current.getData());
				continue;
			} 
			if (null != current.getRightChild()) {
				parent = current;
				current = current.getRightChild();
				queue.add(0, current);
			} 

		}
		
		return list;
		
	}
	
	@Override
	public String toString() {
		return "BinaryTree [root=" + root + "]";
	}

	private Node getMaxValueLesserThanNode(Node root) {
		
		if(null==root)
			return null;
		
		if(null==root.getLeftChild()) {
			return root;
		} else {
			Node cNode = root.getLeftChild();
			// get the largest number in its left subtree
			while(null != cNode.getRightChild()) {
				cNode = cNode.getRightChild();
			}
			return cNode;
		}
		
	}

	public static void main(String[] args) throws CloneNotSupportedException {
		BinaryTree binaryTree = new BinaryTree(true);
	    //BinaryTree.Node n = new BinaryTree.Node(5);
		binaryTree.insertNode(5);
		binaryTree.insertNode(10);
		binaryTree.insertNode(20);
		binaryTree.insertNode(1);
		binaryTree.insertNode(2);
		//binaryTree.insertNode(10);
		
		//System.out.println(binaryTree.hasValue(25));
		System.out.println("1: " + binaryTree);
		System.out.println("2: " + binaryTree.inOrderTravesal(binaryTree.root)); 
	}

}
